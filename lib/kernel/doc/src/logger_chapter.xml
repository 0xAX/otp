<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2017</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>Logging</title>
    <prepared></prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
    <file>logger_chapter.xml</file>
  </header>

  <p>As of OTP-21, Erlang/OTP provides a standard API for logging
    through <c>Logger</c>, which is part of the Kernel
    application. Logger consists of the API for issuing log events,
    and a customizable backend where log handlers, filters and
    formatters can be plugged in.</p>
  <p>By default, the Kernel application installs one log handler at
    system start. This handler is named <c>default</c>. It receives
    and processes standard log events produced by the Erlang runtime
    system, standard behaviours and different Erlang/OTP
    applications. The log events are by default written to the
    terminal.</p>
  <p>You can also configure the system so that the default handler
    prints log events to a single file, or to a set of wrap logs
    via <seealso marker="disk_log"><c>disk_log</c></seealso>.</p>
  <p>By confiugration, you can aslo modify or disable the default
    handler, replace it by a custom handler, and install additional
    handlers.</p>

  <section>
    <title>Overview</title>
    <p>A <em>log event</em> consists of a <em>log level</em>, the
      <em>message</em> to be logged, and <em>metadata</em>.</p>
    <p>The Logger backend forwards log events from the API, first
      through a set of <em>global filters</em>, then through a set
      of <em>handler filters</em> for each log handler.</p>
    <p>Each filter set consists of a <em>log level check</em>,
      followed by zero or more <em>filter functions</em>.</p>
    <p>The following figure show a conseptual overview of Logger. The
      figure shows two log handlers, but any number of handlers can be
      installed.</p>

    <image file="logger_arch.png">
      <icaption>Conceptual Overview</icaption>
    </image>

    <marker id="log_levels"/>
    <p>In accordance with the Syslog protocol, RFC-5424, eight log
      levels can be specified:</p>

    <table align="left">
      <row>
	<cell><strong>Level</strong></cell>
	<cell align="center"><strong>Integer</strong></cell>
	<cell><strong>Description</strong></cell>
      </row>
      <row>
	<cell>emergency</cell>
	<cell align="center">0</cell>
	<cell>system is unusable</cell>
      </row>
      <row>
	<cell>alert</cell>
	<cell align="center">1</cell>
	<cell>action must be taken immediately</cell>
      </row>
      <row>
	<cell>critical</cell>
	<cell align="center">2</cell>
	<cell>critical contidions</cell>
      </row>
      <row>
	<cell>error</cell>
	<cell align="center">3</cell>
	<cell>error conditions</cell>
      </row>
      <row>
	<cell>warning</cell>
	<cell align="center">4</cell>
	<cell>warning conditions</cell>
      </row>
      <row>
	<cell>notice</cell>
	<cell align="center">5</cell>
	<cell>normal but significant conditions</cell>
      </row>
      <row>
	<cell>info</cell>
	<cell align="center">6</cell>
	<cell>informational messages</cell>
      </row>
      <row>
	<cell>debug</cell>
	<cell align="center">7</cell>
	<cell>debug-level messages</cell>
      </row>
      <tcaption>Log Levels</tcaption>
    </table>

    <p>A log event passes the level check if the integer value of its
      log level is less than or equal to the currently configured log
      level, that is, if the event is equally or more severe than the
      configured level.</p>
    <p>The global log level can be overridden by a log level
      configured per module. This is to, for instance, allow more
      verbose logging from a specific part of the system.</p>
    <p>Filter functions can be used for more sophisticated filtering
      than the log level check provides. A filter function can stop or
      pass a log event, based on any of the event's contents. It can
      also modify all parts of the log event. See see
      section <seealso marker="#filters">Filters</seealso> for more
      details.</p>
    <p>If a log event passes through all global filters and all
      handler filters for a specific handler, Logger forwards the event
      to the handler callback. The handler formats and prints the
      event to its destination. See
      section <seealso marker="#handlers">Handlers</seealso> for
      more details.</p>
    <p>Everything upto and including the call to the handler callbacks
      is executed on the client process, that is, the process where
      the log event was issued. It is up to the handler implementation
      if other processes are to be involved or not.</p>
    <p>The handlers are called in sequence, and the order is not
      defined.</p>
  </section>
  <section>
    <marker id="filter"/>
    <title>Filters</title>
    <p>Filters can be global, or attached to a specific
      handler. Logger calls the global filters first, and if they all
      pass, it calls the handler filters for each handler. Logger
      calls the handler callback only if all filters attached to the
      handler in question also pass.</p>
    <p>A filter is defined as:</p>
    <pre>{FilterFun, Extra}</pre>
    <p>where <c>FilterFun</c> is a function of arity 2,
      and <c>Extra</c> is any term. When applying the filter, Logger
      calls the function with the log event as the first argument,
      and the value of <c>Extra</c> as the second
      argument. See <seealso marker="logger#type-filter">
	<c>logger:filter()</c></seealso> for type definitions.</p>
    <p>The filter function can return <c>stop</c>, <c>ignore</c> or
      the (possibly modified) log event.</p>
    <p>If <c>stop</c> is returned, the log event is immediately
      discarded. If the filter is global, no handler filters or
      callbacks are called. If it is a handler filter, the
      corresponding handler callback is not called, but the log event
      is forwarded to the filters attached to the next handler, if
      any.</p>
    <p>If the log event is returned, the next filter function is
      called with the returned value as the first argument. That is,
      if a filter function modifies the log event, the next filter
      function receivea the modified event. The value returned from
      the last filter funcion is the value that the handler callback
      receives.</p>
    <p>If the filter function returns <c>ignore</c>, it means that it
      did not recognize the log event, and thus leaves to other
      filters to decide the event's destiny.</p>
    <p>The configuration
      option <seealso marker="#filter_default"><c>filter_default</c></seealso>
      specifies the behaviour if all filter functions
      return <c>ignore</c>. <c>filter_default</c> is by default set
      to <c>log</c>, meaning that if all filters ignore a log event,
      Logger forwards the event to the handler
      callback. If <c>filter_default</c> is set to <c>stop</c>,
      Logger discards such events.</p>

    <p>Filters are applied in the reverse order of installation,
      meaning that the last added filter is applied first.</p>

    <p>Global filters are added
      with <seealso marker="logger#add_logger_filter-2">
	<c>logger:add_logger_filter/2</c></seealso>
      and removed
      with <seealso marker="logger#remove_logger_filter-1">
	<c>logger:remove_logger_filter/1</c></seealso>. They can also
      be added at system start via Kernel configuration
      parameter <seealso marker="#logger"><c>logger</c></seealso>.</p>
    <p>Handler filters are added with
      with <seealso marker="logger#add_handler_filter-3">
	<c>logger:add_handler_filter/3</c></seealso>
      and removed
      with <seealso marker="logger#remove_handler_filter-2">
	<c>logger:remove_handler_filter/2</c></seealso>. They can also
      be specified directly in the configuration when adding a handler
      with <seealso marker="logger#add_handler/3">
	<c>logger:add_handler/3</c></seealso>
      or via Kernel configuration
      parameter <seealso marker="#logger"><c>logger</c></seealso>.</p>

    <p>To see which filters are currently installed in the system,
      use <seealso marker="logger#i-0"><c>logger:i/0</c></seealso>,
      or <seealso marker="logger#get_logger_config-0">
	<c>logger:get_logger_config/0</c></seealso>
      and <seealso marker="logger#get_handler_config-1">
	<c>logger:get_handler_config/1</c></seealso>. Filters are
	applied in the order they are listed.</p>

    <p>For convenience, the following built-in filters exist:</p>

    <list>
      <item>
	<p><seealso marker="logger_filters#domain-2">
	  <c>logger_filters:domain/2</c></seealso> provides a way of
	  filtering log events based on a
	  <c>domain</c> field <c>Metadata</c>.</p>
      </item>
      <item>
	<p><seealso marker="logger_filters#level-2">
	  <c>logger_filters:level/2</c></seealso> provides a way of
	  filtering log events based on the log level.</p>
      </item>
      <item>
	<p><seealso marker="logger_filters#progress-2">
	  <c>logger_filters:progress/2</c></seealso> stops or allows
	  progress reports from <c>supervisor</c>
	  and <c>application_controller</c>.</p>
      </item>
      <item>
	<p><seealso marker="logger_filters#remote_gl-2">
	  <c>logger_filters:remote_gl/2</c></seealso> stops or allows
	  log events originating from a process that has its group
	  leader on a remote node.</p>
      </item>
    </list>
  </section>

  <section>
    <marker id="handlers"/>
    <title>Handlers</title>
    <p>A handler is defined as a module exporting at least the
      following function:</p>

    <pre><seealso marker="logger#HModule:log-2">log(Log, Config)</seealso></pre>

    <p>This function is called when a log event has passed through all
      global filters, and all handler filters attached to the handler
      in question. The function call is executed on the client
      process, and it is up to the handler implementation if other
      processes are to be involved or not.</p>

    <p>Logger allows adding multiple instances of a handler
      callback. That is, the callback module might be implemented in
      such a way that, by using different handler identities, the same
      callback module can be used for multiple handler
      instances. Handler configuration is per instance.</p>

    <p>In addition to the mandatory callback function <c>log/2</c>, a
      handler module can export the optional callback
      functions <c>adding_handler/1</c>, <c>changing_config/2</c>
      and <c>removing_handler/1</c>. See
      section <seealso marker="logger#handler_callback_functions">Handler
      Callback Functions</seealso> in the logger(3) manual for more
      information about these function.</p>

    <p>The following built-in handlers exist:</p>

    <taglist>
      <tag><c>logger_std_h</c></tag>
      <item>
	<p>This is the default handler used by OTP. Multiple instances
	  can be started, and each instance will write log events to a
	  given destination, console or file. Filters can be used for
	  selecting which event to send to which handler instance.</p>
      </item>

      <tag><c>logger_disk_log_h</c></tag>
      <item>
	<p>This handler behaves much like logger_std_h, except it uses
	  <seealso marker="disk_log"><c>disk_log</c></seealso> as its
	  destination.</p>
      </item>

      <tag><marker id="ErrorLoggerManager"/><c>error_logger</c></tag>
      <item>
	<p>This handler is to be used for backwards compatibility
	  only. It is not started by default, but will be
	  automatically started the first time an <c>error_logger</c>
	  event handler is added
	  with <seealso marker="error_logger#add_report_handler-1">
	    <c>error_logger:add_report_handler/1,2</c></seealso>.</p>

	<p>The old <c>error_logger</c> event handlers in STDLIB and
	  SASL still exist, but they are not added by Erlang/OTP.</p>
      </item>
    </taglist>
  </section>

  <section>
    <marker id="formatters"/>
    <title>Formatters</title>
    <p>A formatter can be used by the handler implementation to do the
      final formatting of a log event, before printing to the
      handler's destination. The handler callback gets the formatter
      information in the handler configuration, which is passed as the
      second argument to <seealso marker="logger#HModule:log-2">
	<c>HModule:log/2</c></seealso>.</p>
    <p>The formatter information consits of a formatter
      module, <c>FModule</c> and its
      configuration, <c>FConfig</c>. <c>FModule</c> must export the
      following function, which can be called by the handler:</p>
    <pre><seealso marker="logger#FModule:format-2">format(Log,FConfig)
	-> FormattedLogEntry</seealso></pre>
    <p>See the <seealso marker="logger_formatter">
	<c>logger_formatter(3)</c></seealso> manual for the full
      description of the default formatter used by Logger.</p>
  </section>

  <section>
    <title>Configuration</title>

    <p>Logger can be configured either when the system starts through
      <seealso marker="config">configuration parameters</seealso>,
      or at run-time by using the <seealso marker="logger">logger(3)</seealso>
      API. The recommended approach is to do the initial configuration in
      the <c>sys.config</c> file and then use the API when some configuration
      has to be changed at run-time, such as the log level.</p>

    <section>
      <title>Kernel Configuration Parameters</title>
      <p>Logger is best configured by using the configuration parameters
      of Kernel. There are four possible configuration parameters:
      <seealso marker="#logger"><c>logger</c></seealso>,
      <seealso marker="kernel_app#logger_level"><c>logger_level</c></seealso>,
      <seealso marker="kernel_app#logger_sasl_compatible"><c>logger_sasl_compatible</c></seealso> and
      <seealso marker="kernel_app#logger_progress_reports"><c>logger_progress_reports</c></seealso>.
      <c>logger_level</c>, <c>logger_sasl_compatible</c> and <c>logger_progress_reports</c> are described in the
      <seealso marker="kernel_app#configuration">Kernel Configuration</seealso>,
      while <c>logger</c> is described below.</p>

        <marker id="logger"/>
        <p><em>logger</em></p>
        <p>The application configuration parameter <c>logger</c> is used to configure
          three different Logger aspects; handlers, logger filters and module levels.
          The configuration is a list containing tagged tuples that look like this:</p>
        <taglist>
          <tag><c>DisableHandler = {handler,default,undefined}</c></tag>
          <item>
	    <p>Disable the default handler. This allows another application
            to add its own default handler. See <seealso marker="logger#add_handlers/1">
            <c>logger:add_handlers/1</c></seealso> for more details.</p>
	    <p>Only one entry of this option is allowed.</p></item>
          <tag><c>AddHandler = {handler,HandlerId,Module,HandlerConfig}</c></tag>
          <item>
	    <p>Add a handler as if <seealso marker="logger:add_handler/3">
            <c>logger:add_handler(HandlerId,Module,HandlerConfig)</c></seealso> is
            called.</p>
	    <p>It is allowed to have multiple entries of this option.</p></item>
          <tag><c>Filters = {filters, default, [Filter]}</c><br/>
          <c>FilterDefault = log | stop</c><br/>
          <c>Filter = {FilterId, {FilterFun, FilterConfig}}</c></tag>
          <item>
	    <p>Add the specified <seealso marker="logger#add_logger_filter/2">
            logger filters</seealso>.</p>
	    <p>Only one entry of this option is allowed.</p></item>
          <tag><c>ModuleLevel = {module_level, Level, [Module]}</c></tag>
          <item>
	    <p>This option configures <seealso marker="logger#set_module_level/2">
            module log level</seealso>.</p>
	    <p>It is allowed to have multiple entries of this option.</p></item>
        </taglist>
        <p>Examples:</p>
        <list>
          <item>
          <p>Output logs into the file &quot;logs/erlang.log&quot;</p>
            <code>
[{kernel,
  [{logger,
    [{handler, default, logger_std_h,
      #{ logger_std_h => #{ type => {file,"log/erlang.log"}}}}]}]}].
            </code>
          </item>
          <item>
          <p>Output logs in single line format</p>
            <code>
[{kernel,
  [{logger,
    [{handler, default, logger_std_h,
      #{ formatter => { logger_formatter,#{ single_line => true}}}}]}]}].
            </code>
          </item>
          <item>
          <p>Add the pid to each log event</p>
            <code>
[{kernel,
  [{logger,
    [{handler, default, logger_std_h,
      #{ formatter => { logger_formatter,
                        #{ template => [time," ",pid," ",msg,"\n"]}}
       }}]}]}].
            </code>
          </item>
          <item>
          <p>Use a different file for debug logging</p>
            <code>
[{kernel,
  [{logger,
    [{handler, default, logger_std_h,
      #{ level => error,
         logger_std_h => #{ type => {file, "log/erlang.log"}}}},
     {handler, info, logger_std_h,
      #{ level => debug,
         logger_std_h => #{ type => {file, "log/debug.log"}}}}
     ]}]}].
            </code>
          </item>
        </list>
    </section>

    <section>
      <title>Global Logger Configuration</title>

      <taglist>
	<tag><c>level = </c><seealso marker="logger#type-level">
	    <c>logger:level()</c></seealso></tag>
	<item>
	  <p>Specifies the global log level to log.</p>
	  <p>See table <seealso marker="#log_levels">Log
	      Levels</seealso> in the Overview section for a listing
	      and description of possible log levels.</p>
	  <p>The initial value of this option is set by the Kernel
	    configuration
	    parameter <seealso marker="kernel_app#logger_level">
	      <c>logger_level</c></seealso>. It can be changed during
	      runtime
	      with <seealso marker="logger#set_logger_config-2">
	      <c>logger:set_logger_config(level,NewLevel)</c></seealso>.</p>
	</item>
	<tag><c>filters = [{</c><seealso marker="logger#type-filter_id">
	    <c>logger:filter_id()</c></seealso><c>,</c>
	  <seealso marker="logger#type-filter">
	    <c>logger:filter()</c></seealso><c>}]</c></tag>
	<item>
	  <p>Global filters are added and removed with
	    <seealso marker="logger#add_logger_filter-2">
	      <c>logger:add_logger_filter/2</c></seealso> and
	    <seealso marker="logger#remove_logger_filter-1">
	      <c>logger:remove_logger_filter/1</c></seealso>,
	    respectively.</p>
	  <p>See section <seealso marker="#filters">Filters</seealso>
	    for more information.</p>
	  <p>Default is <c>[]</c>, that is, no filters exist.</p>
	</item>
	<tag><marker id="filter_default"/><c>filter_default = log | stop</c></tag>
	<item>
	  <p>Specifies what to do with an event if all filters
	    return <c>ignore</c>.</p>
	  <p>See section <seealso marker="#filters">Filters</seealso>
	    for more information about how this option is used.</p>
	  <p>Default is <c>log</c>.</p>
	</item>
      </taglist>
    </section>

    <section>
      <marker id="handler_configuration"/>
      <title>Handler Configuration</title>
      <taglist>
	<tag><c>level = </c><seealso marker="logger#type-level">
	    <c>logger:level()</c></seealso></tag>
	<item>
	  <p>Specifies the log level which the handler logs.</p>
	  <p>See table <seealso marker="#log_levels">Log
	      Levels</seealso> in the Overview section for a listing
	      and description of possible log levels.</p>
	  <p>The log level can be specified when adding the handler,
	    or changed during runtime with, for
	    instance, <seealso marker="logger#set_handler_config/3">
	      <c>logger:set_handler_config/3</c></seealso>.</p>
	  <p>Default is <c>info</c>.</p>
	</item>
	<tag><c>filters = [{</c><seealso marker="logger#type-filter_id">
	    <c>logger:filter_id()</c></seealso><c>,</c>
	  <seealso marker="logger#type-filter">
	    <c>logger:filter()</c></seealso><c>}]</c></tag>
	<item>
	  <p>Handler filters can be specified when adding the handler,
	    or added or removed during runtime with
	    <seealso marker="logger#add_handler_filter-3">
	      <c>logger:add_handler_filter/3</c></seealso> and
	    <seealso marker="logger#remove_handler_filter-2">
	      <c>logger:remove_handler_filter/2</c></seealso>,
	    respectively.</p>
	  <p>See <seealso marker="#filters">Filters</seealso> for more
	    information.</p>
	  <p>Default is <c>[]</c>, that is, no filters exist.</p>
	</item>
	<tag><marker id="filter_default"/><c>filter_default = log | stop</c></tag>
	<item>
	  <p>Specifies what to do with an event if all filters
	    return <c>ignore</c>.</p>
	  <p>See section <seealso marker="#filters">Filters</seealso>
	    for more information about how this option is used.</p>
	  <p>Default is <c>log</c>.</p>
	</item>
	<tag><c>formatter = {module(),</c><seealso marker="logger#type-formatter_config">
	    <c>logger:formatter_config()</c></seealso><c>}</c></tag>
	<item>
	  <p>The formatter which the handler can use for converting
	    the log event term to a printable string.</p>
	  <p>See <seealso marker="#formatters">Formatters</seealso> for more
	    information.</p>
	  <p>Default
	    is <c>{logger_formatter,DefaultFormatterConfig}</c>, see
	    the <seealso marker="logger_formatter">
	      <c>logger_formatter(3)</c></seealso>
	    manual for information about this formatter and its
	    default configuration.</p>
	</item>
        <tag><c>HandlerConfig, atom() = term()</c></tag>
        <item>
          <p>Any keys not listed above are considered to be handler
            specific configuration. The configuration of the Kernel
            handlers can be found in
            the <seealso marker="logger_std_h"><c>logger_std_h(3)</c></seealso>
            and
            <seealso marker="logger_disk_log_h"><c>logger_disk_log_h(3)</c>
	    </seealso> manual pages.</p>
        </item>
      </taglist>

      <p>Notice that <c>level</c> and <c>filters</c> are obeyed by
	Logger itself before forwarding the log events to each
	handler, while <c>formatter</c> and all handle specific
	options are left to the handler implementation.</p>
      <p>All Logger's built-in handlers will call the given formatter
	before printing.</p>
    </section>

  </section>

  <section>
    <marker id="compatibility"/>
    <title>Backwards Compatibility with error_logger</title>
    <p>Logger provides backwards compatibility with the old
      <c>error_logger</c> in the following ways:</p>

    <taglist>
      <tag>API for Logging</tag>
      <item>
	<p>The old <c>error_logger</c> API still exists, but should
	  only be used by legacy code. It will be removed in a later
	  release.</p>
	<p>Calls
	  to <seealso marker="error_logger#error_report-1">
	    <c>error_logger:error_report/1,2</c></seealso>,
	  <seealso marker="error_logger#error_msg-1">
	    <c>error_logger:error_msg/1,2</c></seealso>, and
	  corresponding functions for warning and info messages, are
	  all forwarded to Logger as calls
	  to <seealso marker="logger#log-3">
	    <c>logger:log(Level,Report,Metadata)</c></seealso>.</p>
	<p><c>Level = error | warning | info</c> and is taken
	  from the function name. <c>Report</c> contains the actual
	  log message, and <c>Metadata</c> contains additional
	  information which can be used for creating backwards
	  compatible events for legacy <c>error_logger</c> event
	  handlers, see
	  section <seealso marker="#legacy_event_handlers">Legacy
	  Event Handlers</seealso>.</p>
      </item>
      <tag>Output Format</tag>
      <item>
	<p>To get log events on the same format as produced
	  by <c>error_logger_tty_h</c> and <c>error_logger_file_h</c>,
	  use the default formatter, <c>logger_formatter</c>, with
	  configuration parameter <c>legacy_header=>true</c>. This is
	  also the default.</p>
      </item>
      <tag>Default Format of Log Events from OTP</tag>
      <item>
	<p>By default, all log events originating from within OTP,
	  except the former so called "SASL reports", look the same as
	  before.</p>
      </item>
      <tag><marker id="sasl_reports"/>SASL Reports</tag>
      <item>
	<p>By SASL reports we mean supervisor reports, crash reports
	  and progress reports.</p>
	<p>In earlier releases, these reports were only logged when
	  the SASL application was running, and they were printed
	  trough specific event handlers
	  named <c>sasl_report_tty_h</c>
	  and <c>sasl_report_file_h</c>.</p>
	<p>The destination of these log events were configured by
	  <seealso marker="sasl:sasl_app#deprecated_error_logger_config">SASL
	  configuration parameters</seealso>.</p>
	<p>Due to the specific event handlers, the output format
	  slightly differed from other log events.</p>
	<p>As of OTP-21, the concept of SASL reports is removed,
	  meaning that the default behaviour is as follows:</p>
	<list>
	  <item>Supervisor reports, crash reports and progress reports
	    are no longer connected to the SASL application.</item>
	  <item>Supervisor reports and crash reports are logged by
	    default.</item>
	  <item>Progress reports are not logged by default, but can be
	    enabled with the Kernel configuration
	    parameter <seealso marker="kernel_app#logger_progress_reports">
	    <c>logger_progress_reports</c></seealso>.</item>
	  <item>The output format is the same for all log
	    events.</item>
	</list>
	<p>If the old behaviour is preferred, the Kernel configuation
	  parameter <seealso marker="kernel_app:logger_sasl_compatible">
	    <c>logger_sasl_compatible</c></seealso> can be set
	  to <c>true</c>. The
	  old <seealso marker="sasl:sasl_app#deprecated_error_logger_config">SASL
	  configuration parameters</seealso> can then be used as
	  before, and the SASL reports will only be printed if the
	  SASL application is running, through a second log handler
	  named <c>sasl</c>.</p>
	<p>All SASL reports have a metadata
	  field <c>domain=>[beam,erlang,otp,sasl]</c>, which can be
	  used, for example, by filters to stop or allow the
	  events.</p>
	<p>See the <seealso marker="sasl:error_logging">SASL User's
	  Guide</seealso> for more information about the old SASL
	  error logging functionality.</p>
      </item>
      <tag><marker id="legacy_event_handlers"/>Legacy Event Handlers</tag>
      <item>
	<p>To use event handlers written for <c>error_logger</c>, just
	  add your event handler with</p>
	<code>
error_logger:add_report_handler/1,2.
	</code>
	<p>This will automatically start the <c>error_logger</c>
	  event manager, and add <c>error_logger</c> as a
	  handler to <c>logger</c>, with configuration</p>
<code>
#{level=>info,
  filter_default=>log,
  filters=>[]}.
</code>
	<p>Notice that this handler will ignore events that do not
	  originate from the old <c>error_logger</c> API, or from
	  within OTP. This means that if your code uses the Logger API
	  for logging, then your log events will be discarded by this
	  handler.</p>
	<p>Also notice that <c>error_logger</c> is not overload
	  protected.</p>
      </item>
    </taglist>
  </section>


  <section>
    <title>Error Handling</title>
    <p>Log data is expected to be either a format string and
      arguments, a string
      (<seealso marker="stdlib:unicode#type-chardata">
	<c>unicode:chardata()</c></seealso>), or a report (map or
      key-value list) which can be converted to a format string and
      arguments by the handler. If a report is given, a default report
      callback can be included in the log event's metadata. The
      handler can use this callback for converting the report to a
      format string and arguments. The handler might also do a custom
      conversion if the default format is not desired.</p>
    <p>Logger does, to a certain extent, check its input data
      before forwarding a log event to the handlers, but it does not
      evaluate conversion funs or check the validity of format strings
      and arguments. This means that any filter or handler must be
      careful when formatting the data of a log event, making sure
      that it does not crash due to bad input data or faulty
      callbacks.</p>
    <p>If a filter or handler still crashes, Logger will remove the
      filter or handler in question from the configuration, and then
      print a short error message on the console. A debug event
      containing the crash reason and other details is also issued,
      and can be seen if a handler is installed which logs on debug
      level.</p>
  </section>

  <section>
    <title>Example: add a handler to log debug events to file</title>
    <p>When starting an erlang node, the default behaviour is that all
      log events with level info and above are logged to the
      console. In order to also log debug events, you can either
      change the global log level to <c>debug</c> or add a separate
      handler to take care of this. In this example we will add a new
      handler which prints the debug events to a separate file.</p>
    <p>First, we add an instance of <c>logger_std_h</c> with
      type <c>{file,File}</c>, and we set the handler's level
      to <c>debug</c>:</p>
    <pre>
1> <input>Config = #{level=>debug,logger_std_h=>#{type=>{file,"./debug.log"}}}.</input>
#{logger_std_h => #{type => {file,"./debug.log"}},
  level => debug}
2> <input>logger:add_handler(debug_handler,logger_std_h,Config).</input>
ok</pre>
    <p>By default, the handler receives all events
      (<c>filter_defalt=log</c>), so we need to add a filter to stop
      all non-debug events:</p>
    <pre>
3> <input>Fun = fun(#{level:=debug}=Log,_) -> Log; (_,_) -> stop end.</input>
#Fun&lt;erl_eval.12.98642416>
4> <input>logger:add_handler_filter(debug_handler,allow_debug,{Fun,[]}).</input>
ok</pre>
    <p>And finally, we need to make sure that Logger itself allows
      debug events. This can either be done by setting the global
      log level:</p>
    <pre>
5> <input>logger:set_logger_config(level,debug).</input>
ok</pre>
    <p>Or by allowing debug events from one or a few modules only:</p>
    <pre>
6> <input>logger:set_module_level(mymodule,debug).</input>
ok</pre>

  </section>

  <section>
    <title>Example: implement a handler</title>
    <p>The only requirement that a handler MUST fulfill is to export
      the following function:</p>
    <code>log(logger:log(),logger:config()) ->ok</code>
    <p>It may also implement the following callbacks:</p>
    <code>
adding_handler(logger:config()) -> {ok,logger:config()} | {error,term()}
removing_handler(logger:config()) -> ok
changing_config(logger:config(),logger:config()) -> {ok,logger:config()} | {error,term()}
    </code>
    <p>When <c>logger:add_handler(Id,Module,Config)</c> is called, Logger
      will first call <c>HModule:adding_handler(Config)</c>, and if it
      returns <c>{ok,NewConfig}</c>, <c>NewConfig</c> is written to the
      configuration database. After this, the handler may receive log
      events as calls to <c>HModule:log/2</c>.</p>
    <p>A handler can be removed by calling
      <c>logger:remove_handler(Id)</c>. Logger will call
      <c>HModule:removing_handler(Config)</c>, and then remove the
      handler's configuration from the configuration database.</p>
    <p>When <c>logger:set_handler_config/2,3</c>
      or <c>logger:update_handler_config/2</c> are called, Logger
      calls <c>HModule:changing_config(OldConfig,NewConfig)</c>. If
      this function returns <c>{ok,NewConfig}</c>, <c>NewConfig</c> is
      written to the configuration database.</p>

    <p>A simple handler that prints to the console could be
      implemented as follows:</p>
    <code>
-module(myhandler).
-export([log/2]).

log(Log,#{formatter:={FModule,FConfig}) ->
    io:put_chars(FModule:format(Log,FConfig)).
    </code>

    <p>A simple handler which prints to file could be implemented like
      this:</p>
    <code>
-module(myhandler).
-export([adding_handler/1, removing_handler/1, log/2]).
-export([init/1, handle_call/3, handle_cast/2, terminate/2]).

adding_handler(Config) ->
    {ok,Fd} = file:open(File,[append,{encoding,utf8}]),
    {ok,Config#{myhandler_fd=>Fd}}.

removing_handler(#{myhandler_fd:=Fd}) ->
    _ = file:close(Fd),
    ok.

log(Log,#{myhandler_fd:=Fd,formatter:={FModule,FConfig}}) ->
    io:put_chars(Fd,FModule:format(Log,FConfig)).
    </code>

    <note><p>The above handlers do not have any overload
      protection, and all log events are printed directly from the
      client process.</p></note>

    <p>For examples of overload protection, please refer to the
      implementation
      of <seealso marker="logger_std_h"><c>logger_std_h</c></seealso>
      and <seealso marker="logger_disk_log_h"><c>logger_disk_log_h</c>
      </seealso>.</p>

    <p>Below is a simpler example of a handler which logs through one
      single process.</p>
    <code>
-module(myhandler).
-export([adding_handler/1, removing_handler/1, log/2]).
-export([init/1, handle_call/3, handle_cast/2, terminate/2]).

adding_handler(Config) ->
    {ok,Pid} = gen_server:start(?MODULE,Config),
    {ok,Config#{myhandler_pid=>Pid}}.

removing_handler(#{myhandler_pid:=Pid}) ->
    gen_server:stop(Pid).

log(Log,#{myhandler_pid:=Pid} = Config) ->
    gen_server:cast(Pid,{log,Log,Config}).

init(#{myhandler_file:=File}) ->
    {ok,Fd} = file:open(File,[append,{encoding,utf8}]),
    {ok,#{file=>File,fd=>Fd}}.

handle_call(_,_,State) ->
    {reply,{error,bad_request},State}.

handle_cast({log,Log,Config},#{fd:=Fd} = State) ->
    do_log(Fd,Log,Config),
    {noreply,State}.

terminate(Reason,#{fd:=Fd}) ->
    _ = file:close(Fd),
    ok.

do_log(Fd,Log,#{formatter:={FModule,FConfig}}) ->
    String = FModule:format(Log,FConfig),
    io:put_chars(Fd,String).
    </code>
  </section>

  <section>
    <marker id="overload_protection"/>
    <title>Protecting the Handler from Overload</title>
    <p>In order for the built-in handlers to survive, and stay responsive,
    during periods of high load (i.e. when huge numbers of incoming
    log requests must be handled), a mechanism for overload protection
    has been implemented in the
    <seealso marker="logger_std_h"><c>logger_std_h</c></seealso>
    and <seealso marker="logger_disk_log_h"><c>logger_disk_log_h</c>
    </seealso> handler. The mechanism, used by both handlers, works
    as follows:</p>
    
    <section>
      <title>Message Queue Length</title>
      <p>The handler process keeps track of the length of its message
      queue and reacts in different ways depending on the current status.
      The purpose is to keep the handler in, or (as quickly as possible),
      get the handler into, a state where it can keep up with the pace
      of incoming log requests. The memory usage of the handler must never
      keep growing larger and larger, since that would eventually cause the
      handler to crash. Three thresholds with associated actions have been
      defined:</p>
      
      <taglist>
	<tag><c>toggle_sync_qlen</c></tag>
	<item>
	  <p>The default value of this level is <c>10</c> messages,
	  and as long as the length of the message queue is lower, all log
	  requests are handled asynchronously. This simply means that the
	  process sending the log request (by calling a log function in the
	  Logger API) does not wait for a response from the handler but
	  continues executing immediately after the request (i.e. it will not
	  be affected by the time it takes the handler to print to the log
	  device). If the message queue grows larger than this value, however,
	  the handler starts handling the log requests synchronously instead,
	  meaning the process sending the request will have to wait for a
	  response. When the handler manages to reduce the message queue to a
	  level below the <c>toggle_sync_qlen</c> threshold, asynchronous
	  operation is resumed. The switch from asynchronous to synchronous
	  mode will force the logging tempo of few busy senders to slow down,
	  but can not protect the handler sufficiently in situations of many
	  concurrent senders.</p>
	</item>
	<tag><c>drop_new_reqs_qlen</c></tag>
	<item>
	  <p>When the message queue has grown larger than this threshold, which
	  defaults to <c>200</c> messages, the handler switches to a mode in
	  which it drops any new requests being made. Dropping a message in
	  this state means that the log function never actually sends a message
	  to the handler. The log call simply returns without an action. When
	  the length of the message queue has been reduced to a level below this
	  threshold, synchronous or asynchronous request handling mode is
	  resumed.</p>
	</item>
	<tag><c>flush_reqs_qlen</c></tag>
	<item>
	  <p>Above this threshold, which defaults to <c>1000</c> messages, a
	  flush operation takes place, in which all messages buffered in the
	  process mailbox get deleted without any logging actually taking
	  place. (Processes waiting for a response from a synchronous log request
	  will receive a reply indicating that the request has been dropped).</p>
	</item>
      </taglist>

      <p>For the overload protection algorithm to work properly, it is
      required that:</p>

      <p><c>toggle_sync_qlen =&lt; drop_new_reqs_qlen =&lt; flush_reqs_qlen</c></p>

      <p>and that:</p>

      <p><c>drop_new_reqs_qlen &gt; 1</c></p>

      <p>If <c>toggle_sync_qlen</c> is set to <c>0</c>, the handler will handle all
      requests synchronously. Setting the value of <c>toggle_sync_qlen</c> to the same
      as <c>drop_new_reqs_qlen</c>, disables the synchronous mode. Likewise, setting
      the value of <c>drop_new_reqs_qlen</c> to the same as <c>flush_reqs_qlen</c>,
      disables the drop mode.</p>

      <p>During high load scenarios, the length of the handler message queue
      rarely grows in a linear and predictable way. Instead, whenever the
      handler process gets scheduled in, it can have an almost arbitrary number
      of messages waiting in the mailbox. It's for this reason that the overload
      protection mechanism is focused on acting quickly and quite drastically
      (such as immediately dropping or flushing messages) as soon as a large
      queue length is detected. </p>

      <p>The thresholds listed above may be modified by the user if, e.g, a handler
      shouldn't drop or flush messages unless the message queue length grows
      extremely large. (The handler must be allowed to use large amounts of memory
      under such circumstances however). Another example of when the user might want
      to change the settings is if, for performance reasons, the logging processes must
      never get blocked by synchronous log requests, while dropping or flushing requests
      is perfectly acceptable (since it doesn't affect the performance of the
      loggers).</p>

      <p>A configuration example:</p>
      <code type="none">
logger:add_handler(my_standard_h, logger_std_h,
                   #{logger_std_h =>
                              #{type => {file,"./system_info.log"},
                                toggle_sync_qlen => 100,
                                drop_new_reqs_qlen => 1000,
                                flush_reqs_qlen => 2000}}).
    </code>
    </section>

    <section>
      <title>Controlling Bursts of Log Requests</title>
      <p>A potential problem with large bursts of log requests, is that log files
      may get full or wrapped too quickly (in the latter case overwriting
      previously logged data that could be of great importance). For this reason,
      both built-in handlers offer the possibility to set a maximum level of how
      many requests to process with a certain time frame. With this burst control
      feature enabled, the handler will take care of bursts of log requests
      without choking log files, or the console, with massive amounts of
      printouts. These are the configuration parameters:</p>
      
      <taglist>
	<tag><c>enable_burst_limit</c></tag>
	<item>
	  <p>This is set to <c>true</c> by default. The value <c>false</c>
	  disables the burst control feature.</p>
	</item>
	<tag><c>burst_limit_size</c></tag>
	<item>
	  <p>This is how many requests should be processed within the
	  <c>burst_window_time</c> time frame. After this maximum has been
	  reached, successive requests will be dropped until the end of the
	  time frame. The default value is <c>500</c> messages.</p>
	</item>
	<tag><c>burst_window_time</c></tag>
	<item>
	  <p>The default window is <c>1000</c> milliseconds long.</p>
	</item>
      </taglist>

      <p>A configuration example:</p>
      <code type="none">
logger:add_handler(my_disk_log_h, logger_disk_log_h,
                   #{disk_log_opts =>
                              #{file => "./my_disk_log"},
                     logger_disk_log_h =>
                              #{burst_limit_size => 10,
                                burst_window_time => 500}}).
    </code>
    </section>

    <section>
      <title>Terminating a Large Handler</title>
      <p>A handler process may grow large even if it can manage peaks of high load
      without crashing. The overload protection mechanism includes user configurable
      levels for a maximum allowed message queue length and maximum allowed memory
      usage. This feature is disabled by default, but can be switched on by means
      of the following configuration parameters:</p>
      
      <taglist>
	<tag><c>enable_kill_overloaded</c></tag>
	<item>
	  <p>This is set to <c>false</c> by default. The value <c>true</c>
	  enables the feature.</p>
	</item>
	<tag><c>handler_overloaded_qlen</c></tag>
	<item>
	  <p>This is the maximum allowed queue length. If the mailbox grows larger
	  than this, the handler process gets terminated.</p>
	</item>
	<tag><c>handler_overloaded_mem</c></tag>
	<item>
	  <p>This is the maximum allowed memory usage of the handler process. If
	  the handler grows any larger, the process gets terminated.</p>
	</item>
	<tag><c>handler_restart_after</c></tag>
	<item>
	  <p>If the handler gets terminated because of its queue length or
	  memory usage, it can get automatically restarted again after a
	  configurable delay time. The time is specified in milliseconds
	  and <c>5000</c> is the default value. The value <c>never</c> can
	  also be set, which prevents a restart.</p>
	</item>
      </taglist>
    </section>
  </section>

  <section>
    <title>See Also</title>
    <p>
      <seealso marker="disk_log"><c>disk_log(3)</c></seealso>,
      <seealso marker="error_logger"><c>error_logger(3)</c></seealso>,
      <seealso marker="logger"><c>logger(3)</c></seealso>,
      <seealso marker="logger_disk_log_h"><c>logger_disk_log_h(3)</c></seealso>,
      <seealso marker="logger_filters"><c>logger_filters(3)</c></seealso>,
      <seealso marker="logger_formatter"><c>logger_formatter(3)</c></seealso>,
      <seealso marker="logger_std_h"><c>logger_std_h(3)</c></seealso>,
        <seealso marker="sasl:sasl_app"><c>sasl(6)</c></seealso></p>
  </section>
</chapter>
